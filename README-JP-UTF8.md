awin Ver 2.00 の README-JP-UTF8.txt  日本語版README を勉強がてら MarkDown 記法で書きなおしてみました。一部加筆しています。


[TOC]


####【ライセンス】

awin は GNU GPL V3に従って配布されます。詳しくは、圧縮ファイル内の COPYING ファイルをご覧ください。
GNU GPL V3の日本語訳は [GNU一般公衆利用許諾書](https://www.ipa.go.jp/files/000028332.html)などがあります。

####【このプログラムで出来る事の概要】

1. ウィンドウタイトルに表示されている文字をキーワードにして、該当するウィンドウをアクティブ化する

2. アクティブ化対象のウィンドウが見つからない場合に実行するコマンドを指定できる.
 ウィンドウを切り替えたいプログラムが起動していない場合は起動するという事ができるようになります

3. 毎回ターミナルから実行するのは面倒かつ現実的ではありませんから、任意のショートカットキーが押されたら実行するように指定しておくと便利です。そういう用途のための機能です。
 私の場合は、lxde を使っていますので、
     ~/.config/openbox/lxde-rc.xml
 に登録して使っています。
 これにより今までプログラムの起動として使っていたキーコンビネーションがプログラムの選択にも使えるようになりました。
 私は以前の環境には戻りたくなくなりました。


####【免責事項】

このツールを用いて、不利益・不都合等が発生したとしても、何の保障も補填も致しません。
全ては自己責任においてご使用ください。


####【このプログラムを使うには】

ダウンロードしたこのツールの圧縮ファイルを解凍した先のディレクトリ内で、./configure します。
不足しているパッケージがあれば確認してインストールした上で、再度 ./configure してください。
Makefile が作成されたなら、make して make install します。


####【実行例】

1. ウィンドウの一覧を表示させる
      awin -l
      または
      awin
      ( -l は小文字 )

2. キーワード("Iceweasel":webブラウザの一種)にマッチしたウィンドウタイトルをもつウィンドウの一覧を表示させる[-L]
      awin -L Iceweasel
      ( -L は大文字 )

   小文字の -l の後にキーワードを指定しても無視されます。
   キーワード指定して一覧を表示させる場合はこちらを使用してください。

3. キーワード("Iceweasel")にマッチしたウィンドウタイトルをもつウィンドウの一覧を表示させる[-L]
   指定したキーワードも表示させる[-s]
      awin -L Iceweasel -s
      ( -L は大文字 、 -s は小文字 )

4. キーワード("Iceweasel")の一覧を表示させる[-L]
   最初のものをアクティブ化する。別のワークスペースで表示されていたら、そのワークスペースに切り替える[-a]
      awin -L Iceweasel -a
      ( -L は大文字 、 -a は小文字 )

5. キーワード("Iceweasel")の一覧を表示させる[-L]
   最初のものをアクティブ化する。別のワークスペースで表示されていたら、そのワークスペースから
   今のワークスペースに移動させる[-A]
      awin -L Iceweasel -A
      ( -L は大文字 、 -A は大文字 )

6. キーワード("Iceweasel")の一覧を表示させる[-L]
   最初のものをアクティブ化する[-a/-A]
   もし実行されていなかったら起動(iceweasel)する[-c]
      awin -L Iceweasel -a -c iceweasel
      または
      awin -L Iceweasel -A -c iceweasel
      ( -L は大文字 、 -c は小文字 、-a と -A の違いは4. / 5.を参照)

7. プロセスの一覧を表示させる[-p]
      awin -p
      ( -p は小文字 )

8. キーワード("iceweasel")にマッチしたcmdlineを持つプロセスの一覧を表示させる[-P]
   見つかって、それと同じPIDを持つウィンドウがあれば、それの最初のものをアクティブ化する[-a/-A]
   見つからなければ、iceweaselを起動する[-c]
      awin -P iceweasel -a -c iceweasel
      または
      awin -P iceweasel -A -c iceweasel
      ( -P は大文字 、 -c は小文字 、-a と -A の違いは4. / 5.を参照)

9. キーワード("terminal")にマッチしたcmdlineをもつプロセスの一覧を表示させる[-P]
   見つかって、それらと同じPIDを持つウィンドウがあれば、リストしてアクティブ化する[-a/-A]
   アクティブ化する対象は、それらを全[-g]
   ソート順は、第1カラム(昇順)>第3カラム(昇順)>第4カラム(降順)とする[-o]
      awin -P terminal -a -g -o 1,a,3,a,4,d
      または
      awin -P terminal -A -g -o 1,a,3,a,4,d
      ( -P は大文字 、 -g/-oは小文字 、 -a と -A の違いは4. / 5.を参照)
      少しややこしいですね。-g を指定する事により、複数のウィンドウを一回でアクティブ化できます。
      この場合、ソート順指定は、プロセスの一覧とウィンドウの一覧の両方に対して効きます。
      プロセスの一覧の場合、3番目以降のカラムを指定してもエラーにならず無視されますので、
      ウィンドウをアクティブ化する順番を意識して指定します。


オプションについては、大文字/小文字は区別されます。上記以外のオプションについては、
./configure , make , make install した後で awin --help を実行してみてください。


ウィンドウの一覧を表示させた場合は次が表示されます。

第1カラム  : PID      プロセス毎に違います。通常は数値が小さい方が以前に起動したプロセスです
第2カラム  : machine  実行しているマシン毎に違います（詳しくは聞かないでください）
第3カラム  : class    おおよそプログラム毎に違います（詳しくは聞かないでください）
第4カラム  : title    ウィンドウのタイトルに表示されている文字列です

このツールを使う上で重要なのは第4カラムの title です。
キーワードがマッチするか否かをチェックするのは、基本このカラムの文字列が対象です。
-w が指定された場合は、第3カラムが対象となります。プログラムの種類で選びたい場合はこちらのほうが便利です。
-m が指定された場合は、第2カラムが対象となります。


プロセスの一覧を表示させた場合は次が表示されます。

第1カラム  : PID      プロセス毎に違います。通常は数値が小さい方が以前に起動したプロセスです
第2カラム  : cmdline  プロセスが起動された時のコマンドライン

これにはあなたが明示的に起動したもの以外も含まれます。



このツールでアクティブ化させたいプログラムがある場合、次のような流れを想定しています。
1. そのプログラムを起動させた状態で、"awin -l" を実行し
   どのようなキーワードで title または class をチェックすればいいかを考え、
2. それを指定して "awin -L xxxx" (xxxx  がキーワード)でキーワードの指定の仕方に問題がないか確認。
3. "awin -L xxxx -a"を実行してみてアクティブになる事を確認、
4. 該当プログラムを終了させて"awin -L xxxx -a -c yyyy" (yyyy が起動するコマンド)で起動させる事の確認
5. 任意のショートカットキーに登録する。


なお、キーワードには正規表現が使用可能ですので、ある程度柔軟に記述できます。
正規表現について分からず知りたい方はインターネットで検索して調べてください。
私は限定的にしか知りませんが、それでも役に立ちます。


定義ファイル(~/.config/awin/notmove.list)に、クラスを記述すると、それに合致するウィンドウは、
デスクトップを移動してアクティブ化する対象から外れます。
移動させたくないものがある場合は、このファイルに登録しておくと便利です。
なお、上記ファイルが無い場合、/etc/awin/notmove.list があればそれを読み込みます。使わないでしょうが...



####【注意事項】

1. ツールのメッセジやソース中のコメント等は英語のようなものにしています。
   英語として誤っている部分はありますが、雰囲気で察してください。
   日本人なら分かるはず?です。

2. 指定するキーワードに空白文字が含まれる場合には、キーワード全体をダブルクォーテーションで
   囲むことで私は対応しています。
   また記号が含まれる場合、正規表現の形式として解釈される可能性がありますので、注意が必要です。

3. 起動させるもの (-c で指定するもの)によっては次のようなメッセージが出る場合があります。
>GLib-CRITICAL **: g_slice_set_config: assertion 'sys_page_size == 0' failed
>Gtk-Message: (for origin information, set GTK_DEBUG): failed to retrieve property
>\`GtkRange::activate-slider' of type \`gboolean' from rc file value "((GString*) 0x7f6e58e0fb40)" of type \`GString'
>Gtk-Message: (for origin information, set GTK_DEBUG): failed to retrieve property `GtkRange::activate-slider' of
>type `gboolean' from rc file value "((GString*) 0x7f6e58e0fb40)" of type `GString'

   これは、このツールから出しているものではありません。
   このツールはこんなに長く詳しい(難しい)メッセージは出力しません。
   これはターミナルから直接起動しても出てくるようなメッセージなので、このツールに起因するものではないようです。
   起動するときに標準エラー出力を抑制すれば表示されなくなると思いますが、
   出ても実害はない（模様）だし、全然表示されないのは良くないと思い、特に抑制していません。

   このような状態が気になるコマンドがあれば、末尾に
      awin -a Iceweasel -c "iceweasel 2>/dev/null"
   のようにエラー出力を抑制する事も検討してみてください。
   これは、"iceweasel"コマンドを実行する時に、標準エラー出力をリダイレクトして画面に表示させないようにしています。
    (/dev/null のパーミッションが適切な事が前提です機能)
   ダブルクォーテーションで囲まないと、awin を実行する時のエラー出力を抑制する事になりますので、注意してください。

4. パフォーマンスについて
   C言語で作成していて、複雑な処理はしていないプログラムですので、特に高速化のための工夫はしていませんが、余りに処理が遅いという事はないと思います。
   しかしながら、ご不満を感じさせる事があるかとも思います。その際はご容赦ください。

5. 相性の悪いアプリがあるようです。
   X アプリの中には PID をセットしないものがあり、それをアクティブ化する事については制限がつきます。
   そのようなアプリは -a/-A を用いてのアクティブ化は大丈夫ですが、-P を用いてのアクティブ化は出来ません。
   X では、PID をセットする／しないは、アプリに委ねられているようです。自由ですね。
   そのため、全てのXアプリの PID が awin が使っている X の API で得られる訳ではありません。
   PID が得られなかった場合、awin は 0 として処理を続行します。
   一方、-p/-P オプションで得られる PID は、OS が確実にセットしたものとなります。ユーザーが実行したものは 0 にはなりません。
   そのため、両者は不一致の状態に陥ります。
   -P オプションを指定した場合、該当の PID を持つウィンドウをアクティブ化しようとするために、見つからずにアクティブ化できません。

   そのようなアプリに何があるのかは分かりませんが、mlterm(ver.3.3.8) や xpdf(ver.3.03) はそういうアプリのようです。

   -l オプションで PID が 0 になってしまう場合、ターミナルから「xprop _NET_WM_PID」を実行し、該当するウィンドウをクリックすることで、セットされているか否かが分かります。
      「_NET_WM_PID:  not found.」
   などとでるようであれば、セットされていません。セットされていれば、
      「_NET_WM_PID(CARDINAL) = 3151」
   のようにセットされているPID(この例ですと 3151 )が表示されます。
   セットされているのに、awinで 0 になるのであれば、awin の不具合です。

   またアプリがセットするということは、意図は分かりませんが、OS が認識しているのと異なる PID がセットされる可能性もあるのかも知れません。
   そういう場合も、アクティブ化は正しく動作しない可能性があります。
   アクティブ化されない、あるいは意図しないウィンドウがアクティブ化されるなどです。

   どちらの場合も、awin では対処は難しいと考えています。
   保証されないから使わないというのではなく、使えればラッキー!!!というスタンスでお使いください。

   該当するアプリが見つかった場合、メンテナンスをしている人に連絡をとり、正しい PID をセットするよう要請するのが、もっとも望ましい対処方法と思います。
   で、私は mlterm / xpdf に関して何かアプローチをしたかと問われると、何もしていません。恥ずかしい限りです。
   awin は無名のツールですから、気が引けるのです。自分のツールに不都合なんだという理由が...

6. ソート機能はC言語標準の qsort を利用しています。
   そのため、キーの大小評価として同じとなった場合、元の順序は必ずしも維持されません。
   複数のソート条件を指定して、希望するソート順になるよう工夫してみてください。
   PID はユニークなのでは? と最初思いましたが、そうではないようですね。
   マージソート等のアルゴリズムで実装すればベターなのでしょうが、そこまでの必要性を感じていないので未対応です。

7. 不具合・機能追加の要望等あれば、次へお願いします。
   http://withlife.ciao.jp/bbs/patio/patio.cgi


####【作成経緯】

m-yamashita さんがqiitaに投稿された [Quickey.py](http://qiita.com/m-yamashita/items/8c9b22079fb375653eb2) を見て便利そうだと思いました。[wmctrl](https://sites.google.com/site/tstyblo//wmctrl)もそこで知りました。

Quickey.py を使っても良かったのですが、Autokey は使わないつもりだったのです。非力な環境で使っていますので。
python 経由で使用するのも面倒で...python が分からないというのも大きな理由ですが。

とりあえず、シェルスクリプトで使いそうな機能のみ実装してみようと思ったのですが、give up!
wmctrl の結果を得るのにパイプを使うと、変数のスコープの制限で行いたい処理が記述できませんでした。この制限は忘れやすい...
一旦ファイルを経由すると可能だと思うのですが、パフォーマンスを考えると採用したくない。
実際にはパフォーマンスは大丈夫なんでしょうが、気持ち悪いと感じたのです。しかし、ファイルを経由しない方法が思いつかない。

そこでシェルスクリプトでやろうとした事を、C言語のプログラムとして作成したのが始まりです。
挫折の産物ですが、何とか使えるレベルにはなっていると思います。
python と Quickey.py の両方をロードするより、このツールだけロードする方が I/O 負荷は軽いのではないかと思います。
Ver 2 になってから wmctrl を呼び出すこともなくなりました(一部の機能を見様見真似で内包)ので、より軽く動作すると思います。
但し、どのようなウィンドウ・マネージャで動作するのかについては、分かっていません。


####【プログラム・ソースの簡単な説明】

以下のソース・ファイルで構成されています。

1. awin.c   main 関数を含むプログラム本体  プロセス用関数もここに記述されています。
   awin.h   awin.c のヘッダー・ファイル
2. mywin.c  X Window 関連用関数
   mywin.h  mywin.c のヘッダー・ファイル
3. mymem.c  メモリー管理用関数
   mymem.h  mymem.c のヘッダー・ファイル

次にそれぞれの.cファイル毎に簡単に説明します。改編される場合の一助になれば幸いです。
更新がおろそかになっている部分があるかも知れませんがご容赦ください。

1. awin.c

   次の値が#defineされています。
      BUF_LEN 4096
   用途は文字列配列を宣言するときの添字です。
   検索するとして指定した文字列の格納用、実行するコマンドの格納用、正規表現のコンパイルがエラーになった時の
   詳細取得用で使っています。

   グローバル変数として次が宣言されています。
      　MySortConfig SortConfig[SORT_MAX];
   qsort で指定する比較関数の中で(厳密にはさらにそれから呼ばれる関数の中で)使用される変数で、
   複数のフィールドを指定したソート条件を記憶させるためのものです。

   int IsNumber()
       文字列が数値のみかどうかをチェックします。数値のみであれば桁数を返します。数値以外が含まれれば0を返します。

   int MyCompPList()
       qsort に指定する比較関数です。プロセス情報のソート用です。
       次のMyCompPListA() を呼び出しているだけです。

   int MyCompPListA()
       比較関数の実体です。
       PID と cmdline の比較を実装しています。

   GetProcessList()
       /proc ディレクトリ内を調べて、PID と cmdline を取得します。
       (項目は ps コマンドで表示されるものの PID と CMD に相当します）
       cmdline 内がnull文字で区切られている場合、空白文字に置き換えます。
       google-chrome 等は、全体でとても長いものになります。

   main()
       main 関数です。
       オプション解析、正規表現のコンパイル等を行って、各処理を呼び出したりしています。
       リスト表示の際に、長い cmdline や title のものがあると、非常に見辛くなります。
       画面の幅に合わせて途中までで出力をやめるオプションも考えましたが、真面目に多バイト文字列の事を
       考慮しないとならないようなので、諦めました。
       このプログラムはそこまでするような種類のものではないと思っています。
       リスト表示はどちらかというとおまけの機能です。
       awin -p | less -S 等て対応することを想定します。

   注: awin.h 内で特に注意を要するのは、次の部分です。
         #define PDATA_MAX 11616
       これは、プロセス情報を格納する配列の個数に使用されています。
       あまりに大きいと、その分メモリを消費しますが、あまりに小さいと全てのプロセスの情報を格納できません。
       最初配列を動的に確保していたのですが、細切れのメモリー確保/開放が多いと割と簡単にエラーになりました。
       cmdline の内容を読み込む際に、fopen を利用していたので、内部的にmallocが発生していたも大きいのですが。
       mallocの呼び出し回数の抑制(細切れのメモリー確保を抑制）する一貫として、とりあえず固定配列にしています。
       私の使っているLinuxの設定の上限値がこの値でした。
       このプログラムの想定はデスクトップ用途なので、この大きさは十分過ぎる値だと考えています。
       桁を一つ減らしてもOKなのではないでしょうか。

2. mywin.c
   wmctrl のソース・コードから、最低限必要そうな部分を持ってきて、私が少しでも分かるように手直ししたものが中心です。
   これまで X11 アプリを一つも作ったこともない者が行った作業です。
   不都合に遭遇しては回避策を探すというのを繰り返しているので、色々不十分な点があるかと思います。
   まずい点などありましたら、ご教授頂ければ嬉しいです。

   int  digit()
        数値の桁数を返します。

   void activate_window ()
        ウィンドウをアクティブ化します。

   void move_and_activate_window ()
        現在デスクトップに移動させた後にウィンドウをアクティブ化します。

   int  getWinList()
        ウィンドウ情報のリストを得ます。

   int  MyCompWin()
       qsort に指定する比較関数です。ウィンドウ情報のソート用です。
       後述のMyCompWinA() を呼び出しているだけです。

   void DisplayWinList()
       ウィンドウ情報をリスト表示します。

   int iReadNotMove()
       デスクトップを移動してアクティブ化する対象外となるclassを定義しているファイルを読み込みます。

   unsigned char *get_prop()
       make installcheckを取得します。良く理解出来ていません。

   Window *get_client_list()
       クライアント・リストを取得します。

   char *get_property ()
       文字列型のプロパティを取得します。

   int client_msg()
       クライアント・ウィンドウにイベントを送ります。

   int window_to_desktop ()
       ウィンドウを現在デスクトップに移動させます。

   unsigned long get_pid()
       ウィンドウのプロパティから PID を取得します。
       見慣れた PID にするのに、ちょっとした計算が行われていますが、計算式はネットで漁って見つけました。

   char *get_machine()
       ウィンドウのプロパティから machine を取得します。

   char *get_wmclass()
       ウィンドウのプロパティから class を取得します。

   char *get_title()
       ウィンドウのプロパティから title を取得します。

   int MyCompWinA()
        比較関数の実体です。
        PID、machine、class、title の比較を実装しています。

   注: mywin.h 内で特に注意を要するのは、次の部分だと思います。
        #define WAIT_MICROSECOND_AWTIVATE_AFTER_MOVE  1   /* unit : microsecond  200000 is 0.2 sec. */
       これは、-A オプション指定時の、デスクトップの移動をさせてから、ウィンドウをアクティブにする迄の間の待ち時間です。
       短すぎると、不具合が起きたる可能性があるようです。長くすると、安全ですが待たされます。
       wmctrl では、この部分は100000 ( 0.1 秒)でしたが、私の環境では十分ではない事があるようでした。
       単純に 200000 ( 0.2 秒)にすると、処理は問題ないようでしたが、操作していて引っかかる感じがありました。
       そこで、アクティブ化する直前に、このプログラムの優先順位を最低になるようにしました。システムや他のプログラムを優先して処理できるようにすれば、デスクトップの移動が早く終わるのではと考えたからです。
       (アクティブ化した後は、このプログラムは終了するだけなので、優先順位は戻していません)
       その上で、この値が 0 以上であれば、その時間分を待つようにしました。

       短すぎた場合の経験した不具合ですが、LXPanel( class が panel.lxpanel となっているもの)が画面からなくなりました。
       どういう理屈で不具合になるのか、私には分かりませんので、他にどういう不具合が起こりえるかも分かりません。
       （ひょっとすると、その時のプログラムに存在したとんでもないバグが表面化したのかも知れませんが）
       デスクトップの移動をさせると何かおかしいが移動させない場合は正常だ、という場合には少し長くして様子をみてください。
       私の環境では、今は 0 でも大抵は大丈夫なようですが、たまに移動させたウィンドウ描写が遅れる時があるので、1 にしてあります。
       優先順位が最低であれば、usleepを呼び出す事が意味を持つのだと思っています。
       なお、ご存知でしょうが、この値を指定しても厳密にその時間だけ待つ訳ではありません。
       システムの動作状況、システムタイマーがサポートする単位などによって、設定した値よりも少し待たされると思います。

       なお、この値は、awin.c の中で、複数のウィンドウをデスクトップの移動をさせてウィンドウをアクティブにする処理の中で、
       一つのウィンドウの処理を終えてから次のウィンドウの処理へ進む間の待ち時間にも使用されます。
       待ちを入れないと、私の環境では、やはり LXPanel が消えてしまったのです。

   私の環境:(仮想環境ではありません。)
   |項目      |内容   |
   |:--------|:------|
   |CPU|Intel Core2Duo T710 1.80 GHz 2コア|
   |Memory|3GB|
   |Graphic|Intel GM965|
   |OS|Debian linux (3.16 pae i686)|
   |Destribution| Kona Linux 3.0 Light|
   |Language    | ja_JP.UTF-8 |

3. mymem.c
   1.の注で記した、細切れのメモリー確保を回避するための機能を記述したソースです。
   あまり賢い機能は実装していません。
   awin 自身、起動されたら程なく終了し長居する機能ではないため、メモリ解放機能は実体がありません。
   awin が終了するときに、OS が効率的に開放してくれる事を期待しています。
    (なので、 1. 2. のソースでもあまり積極的にメモリ開放していません。)
   また一旦割り当てたメモリのサイズ変更の機能も提供していません。処理が複雑・大規模になりますし、
   割り当てられたメモリへのアクセス方法にも制約がでかねないためです。
   awin 用に程よい機能にしている積りです。

   void *MyAssignMem()
        メモリー割り当て用関数です。
        後述の MyManageMem() を呼び出します。

   void MyChangeUnitMem()
        メモリーを実際に確保する単位を変更します。
        後述の MyManageMem() を呼び出します。
        確保する単位の初期値は、
            #define MYALLOC_DEFAULT_ALLOC_UNIT  65536
        で指定されています。

   void MyFreeMem()
        割り当てられたメモリー開放用関数です。
        後述の MyManageMem() を呼び出します。
        処理の実体は今はありません。とりあえず用意しただけです。

   int MyManageMem()
        処理の本体です。
        メモリーを次で指定された個数まで、確保し初期化します。
             #define MYALLOC_MAX_POOL            10
        確保したメモリーをMyAssignMem()を経由して部分的にアサインします。
        確保する単位は、MYALLOC_DEFAULT_ALLOC_UNIT または、MyChangeUnitMem()で指定された値のバイト数です。
        但し、要求されたバイト数がそれより大きい場合は、それを満たす大きさのものを確保します。
        この動きを考慮して、MYALLOC_MAX_POOL の値と、MYALLOC_DEFAULT_ALLOC_UNITの値あるいは、MyChangeUnitMem()で指定する値を調整する必要があります。
        通常は、"Err:Exceed allocation pool"のメッセージが表示されたら、値を増やすよう検討する、でOKだと思います。
